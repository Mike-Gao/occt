// Copyright (c) 2015 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <FaceIterator.h>

#include <AIS_ColoredShape.hxx>
#include <AIS_ConnectedInteractive.hxx>
#include <BRepAdaptor_Surface.hxx>
#include <BRepLProp_SLProps.hxx>
#include <BRep_Tool.hxx>
#include <CafShapePrs.h>
#include <Poly_Array1OfTriangle.hxx>
#include <Poly_Triangulation.hxx>
#include <TopExp.hxx>
#include <TopExp_Explorer.hxx>
#include <TopoDS.hxx>

// =======================================================================
// function : FaceIterator
// purpose  :
// =======================================================================
FaceIterator::FaceIterator (const AIS_ListOfInteractive& thePrsList)
: myPrsIter (thePrsList)
{
  Next();
}

// =======================================================================
// function : Next
// purpose  :
// =======================================================================
void FaceIterator::Next()
{
  for (; myPrsIter.More(); myPrsIter.Next())
  {
    Handle(AIS_ConnectedInteractive) aConnected = Handle(AIS_ConnectedInteractive)::DownCast (myPrsIter.Value());
    Handle(AIS_Shape) aShapePrs = Handle(AIS_Shape)::DownCast (!aConnected.IsNull() ? aConnected->ConnectedTo() : myPrsIter.Value());

    ShapePrs = Handle(CafShapePrs)::DownCast (aShapePrs);
    myPrsLocation = TopLoc_Location();
    if (ShapePrs.IsNull())
    {
      Triangulation.Nullify();
      Face.Nullify();
      myFacesMap.Clear();
      continue;
    }
    else if (!aConnected.IsNull()
           && aConnected->LocalTransformation().Form() != gp_Identity)
    {
      myPrsLocation = TopLoc_Location (aConnected->LocalTransformation());
    }

    TopoDS_Shape aShape = ShapePrs->Shape();
    if (aShape.IsNull())
    {
      Triangulation.Nullify();
      Face.Nullify();
      myFacesMap.Clear();
      continue;
    }

    if (myFacesMap.IsEmpty())
    {
      // should be replaced by TopTools_OrientedShapeMaphasher to export correctly composed solids
      // (e.g. shared face should be exported twice with different order of triangles
      //  and possible unique color)
      TopExp::MapShapesAndAncestors (aShape, TopAbs_FACE, TopAbs_SHAPE, myFacesMap);
      if (myFacesMap.IsEmpty())
      {
        Triangulation.Nullify();
        Face.Nullify();
        continue;
      }

      // register compounds generated by XCAFPrs_AISObject for grouping elements with the same style
      const CafDataMapOfShapeColor& aColorsMap = ShapePrs->ShapeColors();
      for (CafDataMapOfShapeColor::Iterator aShapeMapIter (aColorsMap); aShapeMapIter.More(); aShapeMapIter.Next())
      {
        if (aShapeMapIter.Key().ShapeType() != TopAbs_COMPOUND
         || aShapeMapIter.Key().IsEqual (aShape))
        {
          continue;
        }

        for (TopExp_Explorer aCompFaceIter (aShapeMapIter.Key(), TopAbs_FACE); aCompFaceIter.More(); aCompFaceIter.Next())
        {
          const Standard_Integer anIndex = myFacesMap.FindIndex (aCompFaceIter.Current());
          if (anIndex != 0)
          {
            myFacesMap.ChangeFromIndex (anIndex).Append (aShapeMapIter.Key());
          }
        }
      }

      myFaceIter = TopTools_IndexedDataMapOfShapeListOfShape::Iterator (myFacesMap);
    }
    for (; myFaceIter.More(); myFaceIter.Next())
    {
      Face = TopoDS::Face (myFaceIter.Key());
      Triangulation = BRep_Tool::Triangulation (Face, myFaceLocation);
      Trsf = myPrsLocation.Multiplied (myFaceLocation).Transformation();
      if ( Triangulation.IsNull()
       ||  Triangulation->Triangles().Length() == 0
       || !Triangulation->HasUVNodes())
      {
        continue;
      }

      Handle(AIS_ColoredDrawer) aCustomDrawer;
      if (!ShapePrs->FindCustomAspects (Face, aCustomDrawer))
      {
        for (TopTools_ListOfShape::Iterator aParentIter (myFaceIter.Value()); aParentIter.More(); aParentIter.Next())
        {
          if (ShapePrs->FindCustomAspects (aParentIter.Value(), aCustomDrawer))
          {
            break;
          }
        }
        if (aCustomDrawer.IsNull())
        {
          ShapePrs->FindCustomAspects (aShape, aCustomDrawer);
        }
      }
      Drawer = aCustomDrawer;
      if (Drawer.IsNull())
      {
        Drawer = aShapePrs->Attributes();
      }

      myFaceIter.Next();
      return;
    }
    Triangulation.Nullify();
    Face.Nullify();
    myFacesMap.Clear();
    myFaceIter = TopTools_IndexedDataMapOfShapeListOfShape::Iterator();
    Drawer.Nullify();
  }
}
