// Created on: 1993-03-30
// Created by: Laurent BUCHARD
// Copyright (c) 1993-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <AppParCurves_Constraint.hxx>
#include <GeomAbs_SurfaceType.hxx>
#include <IntSurf_Quadric.hxx>
#include <gp_Trsf.hxx>
#include <gp_Trsf2d.hxx>
#include <IntSurf_PntOn2S.hxx>
#include <Precision.hxx>

const Standard_Integer LimRajout = 5;
const Standard_Real RatioTol = 1.5 ;

//=======================================================================
//function : Default constructor
//purpose  : 
//=======================================================================
ApproxInt_Approx::
  ApproxInt_Approx(): myComputeLine(4, 8, 0.001, 0.001, 5, Standard_True),
                      myComputeLineBezier(4, 8, 0.001, 0.001, 5, Standard_True),
                      myApproxBez(Standard_True),
                      myWithTangency(Standard_True),
                      myTol3d(0.0),
                      myTol2d(0.0),
                      myDegMin(4),
                      myDegMax(8),
                      myNbPntMax(30),
                      myNbIterMax(0),
                      myTolReached3d(0.0),
                      myTolReached2d(0.0)
{
  myComputeLine.SetContinuity(2);
  //myComputeLineBezier.SetContinuity(2);
}

//=======================================================================
//function : Perform
//purpose  : 
//=======================================================================
void ApproxInt_Approx::Perform( const Handle(TheWLine)& theline,
                                const Standard_Boolean ApproxXYZ,
                                const Standard_Boolean ApproxU1V1,
                                const Standard_Boolean ApproxU2V2,
                                const Standard_Integer indicemin,
                                const Standard_Integer indicemax)
{
  const Standard_Integer nbpntmax = myNbPntMax;
  const Standard_Boolean cut=Standard_True;

  myTolReached3d = myTolReached2d = 0.; 
  
  Standard_Integer nbpntbez = indicemax-indicemin;
  Standard_Boolean OtherInter = Standard_False;
  if(nbpntbez < LimRajout)
  {
    myApproxBez = Standard_False;
  }
  else 
  {
    myApproxBez = Standard_True;
    myBezToBSpl.Reset();

    //Strange formula. It should be revised.
    //E.g. 
    //  nbpntbez = Min(nbpntbez, nbpntmax);
    //appears better.
    const Standard_Integer nbi = nbpntbez/nbpntmax;
    if(nbi>1)
    {
      nbpntbez /= nbi;
    }
  }

  Standard_Integer imin = indicemin;
  Standard_Integer imax = imin + nbpntbez;

#ifdef OCCT_DEBUG
  //cout << "++++++ ApproxInt_Approx::Perform(...) DUMP ++++++"  << endl;
  //cout << "NbPntMax = " << myNbPntMax    << endl; 
  //cout << "Tol3D    = " << myTol3d       << endl; 
  //cout << "Tol2D    = " << myTol2d       << endl; 
  //cout << "RelTol   = " << (myRelativeTol ? "RELATIVE" : "ABSOLUTE") << endl; 
  //cout << "++++++ ApproxInt_Approx::Perform(...) DUMP ++++++"  << endl;
#endif
  
  const Approx_ParametrizationType parametrization = myComputeLineBezier.Parametrization();

  myComputeLine.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax,
                                                      cut, parametrization);
  myComputeLineBezier.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax,
                                                      cut, parametrization);

  do
  {
    ApproxInt_TheMultiLine myMultiLine(theline, ((ApproxXYZ)? 1 : 0),
                    ((ApproxU1V1)? 1: 0) + ((ApproxU2V2)? 1: 0), ApproxU1V1, imin, imax);
    
    if(myApproxBez)
    {
      myComputeLineBezier.Perform(myMultiLine);
      if (myComputeLineBezier.NbMultiCurves() == 0)
        return;
    }
    else
    {
      myComputeLine.Perform(myMultiLine);
    }
    
    UpdateTolReached();
    
    OtherInter = Standard_False;
    if(myApproxBez)
    {
      for(Standard_Integer nbmc = 1; nbmc <= myComputeLineBezier.NbMultiCurves() ; nbmc++)
      {
        myBezToBSpl.Append(myComputeLineBezier.Value(nbmc));
      }
      if(imax < indicemax)
      { 
        imin = imax;    
        imax = imin+nbpntbez;
        OtherInter = Standard_True;
        if((indicemax-imax) < (nbpntbez/2))
        {
          imax = indicemax;
        }

        imax = CorrectFinishIdx(imin, imax, theline);
      }
    }
  }
  while(OtherInter);

  if(myApproxBez)
  { 
    myBezToBSpl.Perform();
  }
}

//=======================================================================
//function : Perform
//purpose  : 
//=======================================================================
void ApproxInt_Approx::Perform( const ThePSurface& Surf1,
                                const ThePSurface& Surf2,
                                const Handle(TheWLine)& theline,
                                const Standard_Boolean ApproxXYZ,
                                const Standard_Boolean ApproxU1V1,
                                const Standard_Boolean ApproxU2V2,
                                const Standard_Integer indicemin,
                                const Standard_Integer indicemax)
{
  myTolReached3d = myTolReached2d = 0.;

  const GeomAbs_SurfaceType typeS1 = ThePSurfaceTool::GetType(Surf1);
  const GeomAbs_SurfaceType typeS2 = ThePSurfaceTool::GetType(Surf2);

  const Standard_Boolean isQuadric = ((typeS1 == GeomAbs_Plane) ||
                                      (typeS1 == GeomAbs_Cylinder) ||
                                      (typeS1 == GeomAbs_Sphere) ||
                                      (typeS1 == GeomAbs_Cone) ||
                                      (typeS2 == GeomAbs_Plane) ||
                                      (typeS2 == GeomAbs_Cylinder) ||
                                      (typeS2 == GeomAbs_Sphere) ||
                                      (typeS2 == GeomAbs_Cone));


  if(isQuadric)
  {
    IntSurf_Quadric Quad;
    Standard_Boolean SecondIsImplicit=Standard_False;
    switch (typeS1)
    {
    case GeomAbs_Plane:
      Quad.SetValue(ThePSurfaceTool::Plane(Surf1));
      break;

    case GeomAbs_Cylinder:
      Quad.SetValue(ThePSurfaceTool::Cylinder(Surf1));
      break;

    case GeomAbs_Sphere:
      Quad.SetValue(ThePSurfaceTool::Sphere(Surf1));
      break;

    case GeomAbs_Cone:
      Quad.SetValue(ThePSurfaceTool::Cone(Surf1));
      break;

    default:
      {
        SecondIsImplicit = Standard_True;
        switch (typeS2)
        {
        case GeomAbs_Plane:
          Quad.SetValue(ThePSurfaceTool::Plane(Surf2));
          break;

        case GeomAbs_Cylinder:
          Quad.SetValue(ThePSurfaceTool::Cylinder(Surf2));
          break;

        case GeomAbs_Sphere:
          Quad.SetValue(ThePSurfaceTool::Sphere(Surf2));
          break;

        case GeomAbs_Cone:
          Quad.SetValue(ThePSurfaceTool::Cone(Surf2));
          break;

        default:
          break;
        }
      }
      break;
    }

    if(SecondIsImplicit)
    {
      Perform(Surf1,Quad,theline,ApproxXYZ,ApproxU1V1,ApproxU2V2,indicemin,indicemax);
    }
    else
    {
      Perform(Quad,Surf2,theline,ApproxXYZ,ApproxU1V1,ApproxU2V2,indicemin,indicemax);
    }

    return;
  }

  //Here, isQuadric == FALSE

  const Standard_Integer nbpntmax = myNbPntMax;

  //------------------------------------------------------------
  //-- Construction du SvSurfaces
  //------------------------------------------------------------
  ApproxInt_ThePrmPrmSvSurfaces myPrmPrmSvSurfaces(Surf1,Surf2);
  //------------------------------------------------------------
  //-- Construction de la MultiLine
  //------------------------------------------------------------
  Standard_Integer nbpntbez = indicemax-indicemin;

  if(nbpntbez < LimRajout)
  {
    myApproxBez = Standard_False;
  }
  else 
  {
    myApproxBez = Standard_True;
    myBezToBSpl.Reset();

    //Strange formula. It should be revised.
    //E.g. 
    //  nbpntbez = Min(nbpntbez, nbpntmax);
    //appears better.
    const Standard_Integer nbi = nbpntbez/nbpntmax;
    if(nbi>1)
    {
      nbpntbez /= nbi;
    }
  }

  const Standard_Boolean cut = myApproxBez;
  const Standard_Address ptrsvsurf = &myPrmPrmSvSurfaces;

  Standard_Boolean OtherInter = Standard_False;
  Standard_Integer imin = indicemin;
  Standard_Integer imax = imin + nbpntbez;

#ifdef OCCT_DEBUG
//cout << "++++++ ApproxInt_Approx::Perform(...) DUMP ++++++"  << endl;
//cout << "NbPntMax = " << myNbPntMax    << endl; 
//cout << "Tol3D    = " << myTol3d       << endl; 
//cout << "Tol2D    = " << myTol2d       << endl; 
//cout << "RelTol   = " << (myRelativeTol ? "RELATIVE" : "ABSOLUTE") << endl; 
//cout << "++++++ ApproxInt_Approx::Perform(...) DUMP ++++++"  << endl;
#endif

  const Approx_ParametrizationType parametrization = myComputeLineBezier.Parametrization();

  myComputeLine.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax,
                                                                cut, parametrization);
  myComputeLineBezier.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax,
                                                                cut, parametrization);

  do
  {
    ApproxInt_TheMultiLine myMultiLine(theline, ptrsvsurf, ((ApproxXYZ)? 1 : 0),
                  ((ApproxU1V1)? 1: 0) + ((ApproxU2V2)? 1: 0), ApproxU1V1, imin, imax);

    if(myApproxBez)
    {
      myComputeLineBezier.Perform(myMultiLine);
        
      if (myComputeLineBezier.NbMultiCurves() == 0)
        return;
    }
    else
    {
      myComputeLine.Perform(myMultiLine);
    }

    UpdateTolReached();
      
    OtherInter = Standard_False;
    if(myApproxBez)
    {
      for(Standard_Integer nbmc = 1; nbmc <= myComputeLineBezier.NbMultiCurves() ; nbmc++)
      {
        myBezToBSpl.Append(myComputeLineBezier.Value(nbmc));
      }

      if(imax < indicemax)
      {
        imin = imax;
        imax = imin + nbpntbez;
        OtherInter = Standard_True;
        if((indicemax-imax) < (nbpntbez/2))
        {
          imax = indicemax;
        }

        imax = CorrectFinishIdx(imin, imax, theline);
      }
    }
  }
  while(OtherInter);

  if(myApproxBez)
  { 
    myBezToBSpl.Perform();
  }
}

//=======================================================================
//function : Perform
//purpose  : 
//=======================================================================
void ApproxInt_Approx::Perform( const ThePSurface& PSurf,
                                const TheISurface& ISurf,
                                const Handle(TheWLine)& theline,
                                const Standard_Boolean ApproxXYZ,
                                const Standard_Boolean ApproxU1V1,
                                const Standard_Boolean ApproxU2V2,
                                const Standard_Integer indicemin,
                                const Standard_Integer indicemax)
{
  const Standard_Integer nbpntmax = myNbPntMax;
  myTolReached3d = myTolReached2d = 0.;
  
  ApproxInt_TheImpPrmSvSurfaces myImpPrmSvSurfaces(PSurf,ISurf);
  Standard_Integer nbpntbez = indicemax-indicemin;
  Standard_Boolean OtherInter = Standard_False;

  if(nbpntbez < LimRajout)
  {
    myApproxBez = Standard_False;
  }
  else 
  {
    myApproxBez = Standard_True;
    myBezToBSpl.Reset();

    //Strange formula. It should be revised.
    //E.g. 
    //  nbpntbez = Min(nbpntbez, nbpntmax);
    //appears better.

    const Standard_Integer nbi = nbpntbez/nbpntmax;
    if(nbi>1)
    {
      nbpntbez /= nbi;
    }
  }

  const Standard_Boolean cut = myApproxBez;
  const Standard_Address ptrsvsurf = &myImpPrmSvSurfaces;
  const Approx_ParametrizationType parametrization = myComputeLineBezier.Parametrization();
  myComputeLine.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax,
                                                        cut, parametrization);
  myComputeLineBezier.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax,
                                                        cut, parametrization);

  Standard_Integer imin = indicemin;
  Standard_Integer imax = imin + nbpntbez;
  
#ifdef OCCT_DEBUG
  //cout << "++++++ ApproxInt_Approx::Perform(...) DUMP ++++++"  << endl;
  //cout << "NbPntMax = " << myNbPntMax    << endl; 
  //cout << "Tol3D    = " << myTol3d       << endl; 
  //cout << "Tol2D    = " << myTol2d       << endl; 
  //cout << "RelTol   = " << (myRelativeTol ? "RELATIVE" : "ABSOLUTE") << endl; 
  //cout << "++++++ ApproxInt_Approx::Perform(...) DUMP ++++++"  << endl;
#endif

  do
  {
    ApproxInt_TheMultiLine myMultiLine(theline, ptrsvsurf, ((ApproxXYZ)? 1 : 0), ((ApproxU1V1)? 1: 0) + ((ApproxU2V2)? 1: 0), ApproxU1V1, imin, imax);
    if(myApproxBez)
    {
      myComputeLineBezier.Perform(myMultiLine);
      if (myComputeLineBezier.NbMultiCurves() == 0)
        return;
    }
    else
    {
      myComputeLine.Perform(myMultiLine);
    }

    UpdateTolReached();

    OtherInter = Standard_False;
    if(myApproxBez)
    {
      for(Standard_Integer nbmc = 1; nbmc <= myComputeLineBezier.NbMultiCurves(); nbmc++)
      {
        myBezToBSpl.Append(myComputeLineBezier.Value(nbmc));
      }

      if(imax<indicemax)
      {
        imin = imax;
        imax = imin+nbpntbez;
        OtherInter = Standard_True;
        if((indicemax-imax) < (nbpntbez/2))
        {
          imax = indicemax;
        }

        imax = CorrectFinishIdx(imin, imax, theline);
      }
    }
  }
  while(OtherInter);

  if(myApproxBez)
  { 
    myBezToBSpl.Perform();
  }
}

//=======================================================================
//function : Perform
//purpose  : 
//=======================================================================
void ApproxInt_Approx::Perform( const TheISurface& ISurf,
                                const ThePSurface& PSurf,
                                const Handle(TheWLine)& theline,
                                const Standard_Boolean ApproxXYZ,
                                const Standard_Boolean ApproxU1V1,
                                const Standard_Boolean ApproxU2V2,
                                const Standard_Integer indicemin,
                                const Standard_Integer indicemax)
{
  const Standard_Integer nbpntmax = myNbPntMax;
  myTolReached3d = myTolReached2d = 0.;
  
  ApproxInt_TheImpPrmSvSurfaces myImpPrmSvSurfaces(ISurf,PSurf);
  Standard_Integer nbpntbez = indicemax-indicemin;
  
  if(nbpntbez < LimRajout)
  {
    myApproxBez = Standard_False;
  }
  else 
  {
    myApproxBez = Standard_True;
    myBezToBSpl.Reset();

    //Strange formula. It should be revised.
    //E.g. 
    //  nbpntbez = Min(nbpntbez, nbpntmax);
    //appears better.

    const Standard_Integer nbi = nbpntbez/nbpntmax;
    if(nbi>1)
    {
      nbpntbez /= nbi;
    }
  }

  const Standard_Boolean cut = myApproxBez;
  const Standard_Address ptrsvsurf = &myImpPrmSvSurfaces;
  
  Standard_Boolean OtherInter = Standard_False;
  Standard_Integer imin = indicemin;
  Standard_Integer imax = imin + nbpntbez;
  
#ifdef OCCT_DEBUG
  //cout << "++++++ ApproxInt_Approx::Perform(...) DUMP ++++++"  << endl;
  //cout << "NbPntMax = " << myNbPntMax    << endl; 
  //cout << "Tol3D    = " << myTol3d       << endl; 
  //cout << "Tol2D    = " << myTol2d       << endl; 
  //cout << "RelTol   = " << (myRelativeTol ? "RELATIVE" : "ABSOLUTE") << endl; 
  //cout << "++++++ ApproxInt_Approx::Perform(...) DUMP ++++++"  << endl;
#endif
  
  const Approx_ParametrizationType parametrization = myComputeLineBezier.Parametrization();
  myComputeLine.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax,
                                                            cut, parametrization);
  myComputeLineBezier.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax,
                                                            cut, parametrization);

  do
  {
    ApproxInt_TheMultiLine myMultiLine(theline, ptrsvsurf, ((ApproxXYZ)? 1 : 0),
                  ((ApproxU1V1)? 1: 0) + ((ApproxU2V2)? 1: 0), ApproxU1V1, imin, imax);
    if(myApproxBez)
    {
      myComputeLineBezier.Perform(myMultiLine);

#ifdef OCCT_DEBUG
      //myMultiLine.Dump();
#endif

      if (myComputeLineBezier.NbMultiCurves() == 0)
        return;
    }
    else
    {
      myComputeLine.Perform(myMultiLine);
    }

    UpdateTolReached();
    
    OtherInter = Standard_False;
    if(myApproxBez)
    {
      for(Standard_Integer nbmc = 1; nbmc <= myComputeLineBezier.NbMultiCurves(); nbmc++)
      {
        myBezToBSpl.Append(myComputeLineBezier.Value(nbmc));
      }

      if(imax<indicemax)
      {
        imin = imax;
        imax = imin + nbpntbez;
        OtherInter = Standard_True;

        if((indicemax-imax) < (nbpntbez/2))
        {
          imax = indicemax;
        }

        imax = CorrectFinishIdx(imin, imax, theline);
      }
    }
  }
  while(OtherInter);

  if(myApproxBez)
  {
    myBezToBSpl.Perform();
  }
}

//=======================================================================
//function : SetParameters
//purpose  : 
//=======================================================================
void ApproxInt_Approx::SetParameters( const Standard_Real Tol3d,
                                      const Standard_Real Tol2d,
                                      const Standard_Integer DegMin,
                                      const Standard_Integer DegMax,
                                      const Standard_Integer NbIterMax,
                                      const Standard_Integer NbPntMax,
                                      const Standard_Boolean ApproxWithTangency,
                                      const Approx_ParametrizationType Parametrization)
{
  myNbPntMax = NbPntMax;
  myWithTangency = ApproxWithTangency;
  myTol3d        = Tol3d / RatioTol;
  myTol2d        = Tol2d / RatioTol;
  myDegMin       = DegMin;
  myDegMax       = DegMax;
  myNbIterMax    = NbIterMax;
  myComputeLine.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax, Standard_True, Parametrization);

  if(!ApproxWithTangency)
  { 
    myComputeLine.SetConstraints(AppParCurves_PassPoint,AppParCurves_PassPoint);
  }
  
  myComputeLineBezier.Init(myDegMin, myDegMax, myTol3d, myTol2d, myNbIterMax, Standard_True, Parametrization);
  if(!ApproxWithTangency)
  { 
    myComputeLineBezier.SetConstraints(AppParCurves_PassPoint,AppParCurves_PassPoint);
  }

  myApproxBez = Standard_True;
}

//=======================================================================
//function : NbMultiCurves
//purpose  : 
//=======================================================================
Standard_Integer ApproxInt_Approx::NbMultiCurves() const
{
  //  return(myComputeLine.NbMultiCurves());
  return 1;
}

//=======================================================================
//function : UpdateTolReached
//purpose  : 
//=======================================================================
void ApproxInt_Approx::UpdateTolReached()
{
  if (myApproxBez)
  {
    const Standard_Integer NbCurves = myComputeLineBezier.NbMultiCurves() ;
    for (Standard_Integer ICur = 1 ; ICur <= NbCurves ; ICur++)
    {
      Standard_Real Tol3D, Tol2D ;
      myComputeLineBezier.Error (ICur, Tol3D, Tol2D) ;
      myTolReached3d = Max(myTolReached3d, Tol3D);
      myTolReached2d = Max(myTolReached2d, Tol2D);
    }
  }
  else
  {
    myComputeLine.Error (myTolReached3d, myTolReached2d);
  }
}

//=======================================================================
//function : TolReached3d
//purpose  : 
//=======================================================================
Standard_Real ApproxInt_Approx::TolReached3d() const
{ 
  return RatioTol * myTolReached3d;
}

//=======================================================================
//function : TolReached2d
//purpose  : 
//=======================================================================
Standard_Real ApproxInt_Approx::TolReached2d() const
{
  return RatioTol * myTolReached2d;
}

//=======================================================================
//function : IsDone
//purpose  : 
//=======================================================================
Standard_Boolean ApproxInt_Approx::IsDone() const
{ 
  if(myApproxBez)
  { 
    return(myComputeLineBezier.NbMultiCurves() > 0);
  }
  else
  {
    return(myComputeLine.IsToleranceReached());
  }
}

//=======================================================================
//function : Value
//purpose  : 
//=======================================================================
const AppParCurves_MultiBSpCurve& ApproxInt_Approx::Value(const Standard_Integer ) const
{ 
  if(myApproxBez)
  { 
    return(myBezToBSpl.Value());
  }
  else
  { 
    return(myComputeLine.Value());
  }
}

//=======================================================================
//function : CorrectFinishIdx
//purpose  : 
//=======================================================================
Standard_Integer ApproxInt_Approx::CorrectFinishIdx(const Standard_Integer theMinIdx,
                                                    const Standard_Integer theMaxIdx,
                                                    const Handle(TheWLine)& theline)
{
  const Standard_Real aNullCoeff = 1.0e-16;
  const Standard_Real aLimitMaxCoeff = 1.0 / 2500.0;
  Standard_Real aDist = theline->Point(theMinIdx).Value().SquareDistance(
                        theline->Point(theMinIdx + 1).Value());

  for(Standard_Integer anIdx = theMinIdx + 1; anIdx < theMaxIdx - 1; anIdx++)
  {
    const Standard_Real aNextDist = theline->Point(anIdx).Value().
                                      SquareDistance(theline->Point(anIdx + 1).Value());
    const Standard_Real aCoeff = Min (aNextDist, aDist) / Max (aNextDist, aDist);

    //
    if (aCoeff < aLimitMaxCoeff &&        // Base criteria.
        aNextDist > aDist &&              // Step increasing.
        aNextDist > aNullCoeff &&         // Avoid separation in case of too small step.
        aDist > aNullCoeff)               // Usually found when purger not invoked (blend).
    {
      return anIdx;
    }
    aDist = aNextDist;
  }
  return theMaxIdx;
}
