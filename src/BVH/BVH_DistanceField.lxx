// Created on: 2014-09-06
// Created by: Denis BOGOLEPOV
// Copyright (c) 2013-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <BVH_Triangulation.hxx>

#ifdef HAVE_TBB
  // On Windows, function TryEnterCriticalSection has appeared in Windows NT
  // and is surrounded by #ifdef in MS VC++ 7.1 headers.
  // Thus to use it we need to define appropriate macro saying that we will
  // run on Windows NT 4.0 at least
  #if defined(_WIN32) && !defined(_WIN32_WINNT)
    #define _WIN32_WINNT 0x0501
  #endif

  #include <tbb/tbb.h>
#endif

// =======================================================================
// function : BVH_DistanceField
// purpose  :
// =======================================================================
template<class T, int N>
BVH_DistanceField<T, N>::BVH_DistanceField (const Standard_Integer theMaximumSize,
                                            const Standard_Boolean theComputeSign)
: myMaximumSize (theMaximumSize),
  myComputeSign (theComputeSign)
{
  Standard_STATIC_ASSERT (N == 3 || N == 4);

  myVoxelData = new T[myMaximumSize * myMaximumSize * myMaximumSize];
}

// =======================================================================
// function : ~BVH_DistanceField
// purpose  :
// =======================================================================
template<class T, int N>
BVH_DistanceField<T, N>::~BVH_DistanceField()
{
  delete [] myVoxelData;
}

namespace BVH
{
  //=======================================================================
  //function : DistanceToBox
  //purpose  : Computes squared distance from point to box
  //=======================================================================
  template<class T, int N>
  T DistanceToBox (const typename VectorType<T, N>::Type& thePnt,
                   const typename VectorType<T, N>::Type& theMin,
                   const typename VectorType<T, N>::Type& theMax)
  {
    Standard_STATIC_ASSERT (N == 3 || N == 4);

    T aNearestX = Min (Max (thePnt.x(), theMin.x()), theMax.x());
    T aNearestY = Min (Max (thePnt.y(), theMin.y()), theMax.y());
    T aNearestZ = Min (Max (thePnt.z(), theMin.z()), theMax.z());

    if (aNearestX == thePnt.x()
     && aNearestY == thePnt.y()
     && aNearestZ == thePnt.z())
    {
      return static_cast<T> (0);
    }

    aNearestX -= thePnt.x();
    aNearestY -= thePnt.y();
    aNearestZ -= thePnt.z();

    return aNearestX * aNearestX +
           aNearestY * aNearestY +
           aNearestZ * aNearestZ;
  }
}

#define BVH_DOT3(A, B) (A.x() * B.x() + A.y() * B.y() + A.z() * B.z())

//=======================================================================
//function : directToTrg
//purpose  : Returns closest feature and direction to it
// ======================================================================
template<class T, int N>
std::pair<typename BVH_DistanceField<T, N>::BVH_VecNt, typename BVH_DistanceField<T, N>::Feature>
  BVH_DistanceField<T, N>::directToTrg (const BVH_VecNt& thePnt, const Standard_Integer theTrgIdx)
{
  Standard_STATIC_ASSERT (N == 3 || N == 4);

  const BVH_Vec4i aTrg = myMesh->Elements[theTrgIdx];

  const BVH_VecNt aVertA = myMesh->Vertices[aTrg.x()];
  const BVH_VecNt aVertB = myMesh->Vertices[aTrg.y()];
  const BVH_VecNt aVertC = myMesh->Vertices[aTrg.z()];

  const BVH_VecNt aAB = aVertB - aVertA;
  const BVH_VecNt aAC = aVertC - aVertA;
  const BVH_VecNt aAP = thePnt - aVertA;

  const T aABdotAP = BVH_DOT3 (aAB, aAP);
  const T aACdotAP = BVH_DOT3 (aAC, aAP);

  if (aABdotAP <= static_cast<T> (0) && aACdotAP <= static_cast<T> (0))
  {
    return std::make_pair (aAP, Feature (VERT_ID, aTrg.x()));
  }

  const BVH_VecNt aBC = aVertC - aVertB;
  const BVH_VecNt aBP = thePnt - aVertB;

  const T aBAdotBP = -BVH_DOT3 (aAB, aBP);
  const T aBCdotBP =  BVH_DOT3 (aBC, aBP);

  if (aBAdotBP <= static_cast<T> (0) && aBCdotBP <= static_cast<T> (0))
  {
    return std::make_pair (aBP, Feature (VERT_ID, aTrg.y()));
  }

  const BVH_VecNt aCP = thePnt - aVertC;

  const T aCBdotCP = -BVH_DOT3 (aBC, aCP);
  const T aCAdotCP = -BVH_DOT3 (aAC, aCP);

  if (aCAdotCP <= static_cast<T> (0) && aCBdotCP <= static_cast<T> (0))
  {
    return std::make_pair (aCP, Feature (VERT_ID, aTrg.z()));
  }

  const T aACdotBP = BVH_DOT3 (aAC, aBP);

  const T aVC = aABdotAP * aACdotBP + aBAdotBP * aACdotAP;

  if (aVC <= static_cast<T> (0) && aABdotAP >= static_cast<T> (0) && aBAdotBP >= static_cast<T> (0))
  {
    return std::make_pair (aAP - aAB * (aABdotAP / (aABdotAP + aBAdotBP)), Feature (aTrg.x(), aTrg.y()));
  }

  const T aABdotCP = BVH_DOT3 (aAB, aCP);

  const T aVA = aBAdotBP * aCAdotCP - aABdotCP * aACdotBP;

  if (aVA <= static_cast<T> (0) && aBCdotBP >= static_cast<T> (0) && aCBdotCP >= static_cast<T> (0))
  {
    return std::make_pair (aBP - aBC * (aBCdotBP / (aBCdotBP + aCBdotCP)), Feature (aTrg.y(), aTrg.z()));
  }

  const T aVB = aABdotCP * aACdotAP + aABdotAP * aCAdotCP;

  if (aVB <= static_cast<T> (0) && aACdotAP >= static_cast<T> (0) && aCAdotCP >= static_cast<T> (0))
  {
    return std::make_pair (aAP - aAC * (aACdotAP / (aACdotAP + aCAdotCP)), Feature (aTrg.x(), aTrg.z()));
  }

  const T aNorm = static_cast<T> (1.0) / (aVA + aVB + aVC);

  const T aU = aVA * aNorm;
  const T aV = aVB * aNorm;

  const BVH_VecNt aDirect = thePnt - (aVertA * aU + aVertB * aV + aVertC * (static_cast<T> (1.0) - aU - aV));

  return std::make_pair (aDirect, Feature (FACE_ID, theTrgIdx));
}

//=======================================================================
//function : squareDistanceToMesh
//purpose  : Computes squared distance from point to BVH triangulation
//=======================================================================
template<class T, int N>
T BVH_DistanceField<T, N>::squareDistanceToMesh (const BVH_VecNt& thePnt, Standard_Boolean& theIsOut)
{
  Standard_STATIC_ASSERT (N == 3 || N == 4);

  T aMinDist = std::numeric_limits<T>::max();

  const NCollection_Handle<BVH_Tree<T, N> >& aBVH = myMesh->BVH();

  if (aBVH.IsNull())
  {
    return Standard_False;
  }

  std::pair<Standard_Integer, T> aStack[32];

  Standard_Integer aHead = -1;
  Standard_Integer aNode =  0; // root node

  for (;;)
  {
    BVH_Vec4i aData = aBVH->NodeInfoBuffer()[aNode];

    if (aData.x() == 0) // if inner node
    {
      const T aDistToLft = BVH::DistanceToBox<T, N> (thePnt,
                                                     aBVH->MinPoint (aData.y()),
                                                     aBVH->MaxPoint (aData.y()));

      const T aDistToRgh = BVH::DistanceToBox<T, N> (thePnt,
                                                     aBVH->MinPoint (aData.z()),
                                                     aBVH->MaxPoint (aData.z()));

      const Standard_Boolean aHitLft = aDistToLft <= aMinDist;
      const Standard_Boolean aHitRgh = aDistToRgh <= aMinDist;

      if (aHitLft & aHitRgh)
      {
        aNode = (aDistToLft < aDistToRgh) ? aData.y() : aData.z();

        aStack[++aHead] = std::pair<Standard_Integer, T> (
          aDistToLft < aDistToRgh ? aData.z() : aData.y(), Max (aDistToLft, aDistToRgh));
      }
      else
      {
        if (aHitLft | aHitRgh)
        {
          aNode = aHitLft ? aData.y() : aData.z();
        }
        else
        {
          if (aHead < 0)
            return aMinDist;

          std::pair<Standard_Integer, T>& anInfo = aStack[aHead--];

          while (anInfo.second > aMinDist)
          {
            if (aHead < 0)
              return aMinDist;

            anInfo = aStack[aHead--];
          }

          aNode = anInfo.first;
        }
      }
    }
    else  // if leaf node
    {
      for (Standard_Integer aTrgIdx = aData.y(); aTrgIdx <= aData.z(); ++aTrgIdx)
      {
        std::pair<BVH_VecNt, Feature> aDirToFeature = directToTrg (thePnt, aTrgIdx);

        const T aDistance = BVH_DOT3 (aDirToFeature.first,
                                      aDirToFeature.first);

        if (aDistance < aMinDist)
        {
          aMinDist = aDistance;

          if (myComputeSign)
          {
            const BVH_VecNt aNormal = normalToFeature (aDirToFeature.second);

            theIsOut = BVH_DOT3 (aNormal, aDirToFeature.first) > T(0.0);
          }
        }
      }

      if (aHead < 0)
        return aMinDist;

      std::pair<Standard_Integer, T>& anInfo = aStack[aHead--];

      while (anInfo.second > aMinDist)
      {
        if (aHead < 0)
          return aMinDist;

        anInfo = aStack[aHead--];
      }

      aNode = anInfo.first;
    }
  }
}

#ifdef HAVE_TBB

//! Tool object for parallel construction of distance field (uses Intel TBB).
template<class T, int N>
class BVH_ParallelDistanceFieldBuilder
{
private:

  //! Output distance field.
  BVH_DistanceField<T, N>* myOutField;

public:

  BVH_ParallelDistanceFieldBuilder (BVH_DistanceField<T, N>* theOutField)
  : myOutField (theOutField)
  {
    //
  }

  void operator() (const tbb::blocked_range<Standard_Integer>& theRange) const
  {
    myOutField->buildSlices (theRange.begin(), theRange.end());
  }
};

#endif

//=======================================================================
//function : normalToFeature
//purpose  : Computes the normal to the given triangle feature
//=======================================================================
template<class T, int N>
typename BVH_DistanceField<T, N>::BVH_VecNt BVH_DistanceField<T, N>::normalToFeature (const Feature& theFeature)
{
  std::map<Feature, BVH_VecNt, SymmetricalPairComparator>::iterator aFeatureIt = myFeatureNormalMap.find (theFeature);

  Standard_ASSERT_RAISE (aFeatureIt != myFeatureNormalMap.end(), "Failed to retrieve feature normal");

  return aFeatureIt->second;
}

// =======================================================================
// function : Build
// purpose  : Builds 3D distance field from BVH geometry
// =======================================================================
template<class T, int N>
Standard_Boolean BVH_DistanceField<T, N>::Build (BVH_Triangulation<T, N>* theMesh)
{
  myMesh = theMesh;

  if (myMesh->Size() == 0)
  {
    return Standard_False;
  }

  //----------------------------------------------------------------------
  // Compute pseudo-normals
  //----------------------------------------------------------------------

  myFeatureNormalMap.clear();

  if (myComputeSign)
  {
    std::map<Feature, std::set<Standard_Integer>, SymmetricalPairComparator> aConnectivityMap;

    for (size_t aTrgIdx = 0; aTrgIdx < myMesh->Elements.size(); ++aTrgIdx) // build connectivity map
    {
      const BVH_Vec4i aTrg = myMesh->Elements[aTrgIdx];

      const BVH_VecNt aTrgVrt0 = myMesh->Vertices[aTrg.x()];
      const BVH_VecNt aTrgVrt1 = myMesh->Vertices[aTrg.y()];
      const BVH_VecNt aTrgVrt2 = myMesh->Vertices[aTrg.z()];

      const BVH_VecNt aTrgEdges[] = { aTrgVrt1 - aTrgVrt0,
                                      aTrgVrt2 - aTrgVrt0 };

      BVH_VecNt aNormal;

      aNormal.x() = aTrgEdges[0].y() * aTrgEdges[1].z() - aTrgEdges[0].z() * aTrgEdges[1].y();
      aNormal.y() = aTrgEdges[0].z() * aTrgEdges[1].x() - aTrgEdges[0].x() * aTrgEdges[1].z();
      aNormal.z() = aTrgEdges[0].x() * aTrgEdges[1].y() - aTrgEdges[0].y() * aTrgEdges[1].x();

      myFeatureNormalMap[std::make_pair (FACE_ID, aTrgIdx)] = aNormal / std::sqrt (BVH_DOT3 (aNormal, aNormal));

      for (Standard_Integer aVrtStart = 0, aVrtEnd = 1; aVrtStart < 3; ++aVrtStart, aVrtEnd = (aVrtEnd + 1) % 3)
      {
        aConnectivityMap[Feature (aTrg[aVrtStart], aTrg[aVrtEnd])].insert (aTrgIdx);
      }

      for (Standard_Integer aVrtIdx = 0; aVrtIdx < 3; ++aVrtIdx)
      {
        aConnectivityMap[Feature (VERT_ID, aTrg[aVrtIdx])].insert (aTrgIdx);
      }
    }

    std::map<Feature, std::set<Standard_Integer>, SymmetricalPairComparator>::iterator aFeatureIter;

    for (aFeatureIter = aConnectivityMap.begin(); aFeatureIter != aConnectivityMap.end(); ++aFeatureIter)
    {
      BVH_VecNt aNormal;

      for (std::set<Standard_Integer>::iterator aTrgIt = aFeatureIter->second.begin(); aTrgIt != aFeatureIter->second.end(); ++aTrgIt)
      {
        aNormal += myFeatureNormalMap[std::make_pair (FACE_ID, *aTrgIt)];
      }

      myFeatureNormalMap[aFeatureIter->first] = aNormal;
    }
  }

  //----------------------------------------------------------------------
  // Adjust parameters of voxel set
  //----------------------------------------------------------------------

  const BVH_VecNt aBoxSize = myMesh->Box().Size();

  const T aMaxBoxSide = Max (Max (aBoxSize.x(), aBoxSize.y()), aBoxSize.z());

  myDimensionX = static_cast<Standard_Integer> (myMaximumSize * aBoxSize.x() / aMaxBoxSide);
  myDimensionY = static_cast<Standard_Integer> (myMaximumSize * aBoxSize.y() / aMaxBoxSide);
  myDimensionZ = static_cast<Standard_Integer> (myMaximumSize * aBoxSize.z() / aMaxBoxSide);

  myDimensionX = Min (myMaximumSize, Max (myDimensionX, 16));
  myDimensionY = Min (myMaximumSize, Max (myDimensionY, 16));
  myDimensionZ = Min (myMaximumSize, Max (myDimensionZ, 16));

  const BVH_VecNt aGlobalBoxMin = myMesh->Box().CornerMin();
  const BVH_VecNt aGlobalBoxMax = myMesh->Box().CornerMax();

  const Standard_Integer aVoxelOffset = 2;

  myCornerMin.x() = aGlobalBoxMin.x() - aVoxelOffset * aBoxSize.x() / (myDimensionX - 2 * aVoxelOffset);
  myCornerMin.y() = aGlobalBoxMin.y() - aVoxelOffset * aBoxSize.y() / (myDimensionY - 2 * aVoxelOffset);
  myCornerMin.z() = aGlobalBoxMin.z() - aVoxelOffset * aBoxSize.z() / (myDimensionZ - 2 * aVoxelOffset);

  myCornerMax.x() = aGlobalBoxMax.x() + aVoxelOffset * aBoxSize.x() / (myDimensionX - 2 * aVoxelOffset);
  myCornerMax.y() = aGlobalBoxMax.y() + aVoxelOffset * aBoxSize.y() / (myDimensionY - 2 * aVoxelOffset);
  myCornerMax.z() = aGlobalBoxMax.z() + aVoxelOffset * aBoxSize.z() / (myDimensionZ - 2 * aVoxelOffset);

  myVoxelSize.x() = (myCornerMax.x() - myCornerMin.x()) / myDimensionX;
  myVoxelSize.y() = (myCornerMax.y() - myCornerMin.y()) / myDimensionY;
  myVoxelSize.z() = (myCornerMax.z() - myCornerMin.z()) / myDimensionZ;

  //----------------------------------------------------------------------
  // Perform calculations
  //----------------------------------------------------------------------

#ifdef HAVE_TBB
  tbb::parallel_for (
    tbb::blocked_range<Standard_Integer> (0, myDimensionZ), BVH_ParallelDistanceFieldBuilder<T, N> (this));
#else
  buildSlices (0, myDimensionZ);
#endif

  return Standard_True;
}

#undef BVH_DOT3

// =======================================================================
// function : buildSlices
// purpose  : Performs building of distance field for the given Z slices
// =======================================================================
template<class T, int N>
void BVH_DistanceField<T, N>::buildSlices (Standard_Integer theStartSlice, Standard_Integer theFinalSlice)
{
  for (Standard_Integer aZ = theStartSlice; aZ < theFinalSlice; ++aZ)
  {
    for (Standard_Integer aY = 0; aY < myDimensionY; ++aY)
    {
      for (Standard_Integer aX = 0; aX < myDimensionX; ++aX)
      {
        BVH_VecNt aCenter;
        
        aCenter.x() = myCornerMin.x() + myVoxelSize.x() * (aX + static_cast<T> (0.5));
        aCenter.y() = myCornerMin.y() + myVoxelSize.y() * (aY + static_cast<T> (0.5));
        aCenter.z() = myCornerMin.z() + myVoxelSize.z() * (aZ + static_cast<T> (0.5));

        Standard_Boolean isOutside = Standard_True;

        const T aDistance = std::sqrt (squareDistanceToMesh (aCenter, isOutside));

        Voxel (aX, aY, aZ) = (!myComputeSign || isOutside) ? aDistance : -aDistance;
      }
    }

    std::cout << "*";
  }
}

// =======================================================================
// function : Calculate
// purpose  : Calculates distance at the given point
// =======================================================================
template<class T, int N>
T BVH_DistanceField<T, N>::Calculate (const BVH_VecNt& thePoint)
{
  const BVH_VecNt aLocalPnt = thePoint.cwiseMin (myCornerMax).cwiseMax (myCornerMin) - myCornerMin;

  const T aGridPntX = aLocalPnt.x() / myVoxelSize.x() - static_cast<T> (0.5);
  const T aGridPntY = aLocalPnt.y() / myVoxelSize.y() - static_cast<T> (0.5);
  const T aGridPntZ = aLocalPnt.z() / myVoxelSize.z() - static_cast<T> (0.5);

  const Standard_Integer aCellX = static_cast<Standard_Integer> (std::floor (aGridPntX));
  const Standard_Integer aCellY = static_cast<Standard_Integer> (std::floor (aGridPntY));
  const Standard_Integer aCellZ = static_cast<Standard_Integer> (std::floor (aGridPntZ));

  const T aRatioX = aGridPntX - aCellX;
  const T aRatioY = aGridPntY - aCellY;
  const T aRatioZ = aGridPntZ - aCellZ;

  const T aInterpValueMinYMinZ =
    Voxel (aCellX + 0, aCellY + 0, aCellZ + 0) * (T(1.0) - aRatioX) + Voxel (aCellX + 1, aCellY + 0, aCellZ + 0) * aRatioX;
  const T aInterpValueMaxYMinZ =
    Voxel (aCellX + 0, aCellY + 1, aCellZ + 0) * (T(1.0) - aRatioX) + Voxel (aCellX + 1, aCellY + 1, aCellZ + 0) * aRatioX;
  const T aInterpValueMinYMaxZ =
    Voxel (aCellX + 0, aCellY + 0, aCellZ + 1) * (T(1.0) - aRatioX) + Voxel (aCellX + 1, aCellY + 0, aCellZ + 1) * aRatioX;
  const T aInterpValueMaxYMaxZ =
    Voxel (aCellX + 0, aCellY + 1, aCellZ + 1) * (T(1.0) - aRatioX) + Voxel (aCellX + 1, aCellY + 1, aCellZ + 1) * aRatioX;

  const T aInterpValueMinZ = aInterpValueMinYMinZ * (T(1.0) - aRatioY) + aInterpValueMaxYMinZ * aRatioY;
  const T aInterpValueMaxZ = aInterpValueMinYMaxZ * (T(1.0) - aRatioY) + aInterpValueMaxYMaxZ * aRatioY;

  return aInterpValueMinZ * (T(1.0) - aRatioZ) + aInterpValueMaxZ * aRatioZ;
}
