// Copyright (c) 1995-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <Geom2d_Line.hxx>
#include <GCE2d_MakeLine.hxx>


#ifndef OCCT_DEBUG
#define No_Standard_RangeError
#define No_Standard_OutOfRange
#endif


const Standard_Real TolDiscr = 1.e-8;
const Standard_Real TolB = 1.e-5;

static Standard_Integer RealSign(const Standard_Real aValue)
{
  if (aValue >= 0.)
    return 1;
  else return -1;
}

static Standard_Boolean ComputeB11orB22(TheIWFunction& sp,
                                        Standard_Boolean& IsDiscriminantNull,
                                        Standard_Integer& SignOfBcoeff,
                                        gp_Vec& Pu,
                                        gp_Vec& Pv,
                                        Standard_Real& B11,
                                        Standard_Real& B22,
                                        Standard_Real& B12)
{
  gp_Vec Puu, Puv, Pvv;
  gp_Vec Iu, Iv, Iuu, Iuv, Ivv;
  gp_Vec NormalP, NormalI;

  if (!sp.DerivativesAndNormalOnPSurf(Pu, Pv, NormalP, Puu, Pvv, Puv))
    return Standard_False;
  if (!sp.DerivativesAndNormalOnISurf(Iu, Iv, NormalI, Iuu, Ivv, Iuv))
    return Standard_False;

  Standard_Real Lp, Mp, Np, Li, Mi, Ni; //second fundamental form coefficients
  Lp = Puu * NormalP;
  Mp = Puv * NormalP;
  Np = Pvv * NormalP;
  Li = Iuu * NormalI;
  Mi = Iuv * NormalI;
  Ni = Ivv * NormalI;

  gp_Vec Normal;
  if (NormalP * NormalI < 0.)
    NormalI.Reverse();
  Normal.SetXYZ(0.5*(NormalP.XYZ() + NormalI.XYZ()));
  Normal.Normalize();

  Standard_Real A11, A12, A21, A22;
  Standard_Real NormIdotNorm = (Iu ^ Iv) * Normal;
  A11 = ((Pu ^ Iv) * Normal) / NormIdotNorm;
  A12 = ((Pv ^ Iv) * Normal) / NormIdotNorm;
  A21 = ((Iu ^ Pu) * Normal) / NormIdotNorm;
  A22 = ((Iu ^ Pv) * Normal) / NormIdotNorm;

  //Standard_Real B11, B12, B22;
  B11 = A11*A11*Li + 2*A11*A21*Mi + A21*A21*Ni - Lp;
  B12 = A11*A12*Li + (A11*A22 + A21*A12)*Mi + A21*A22*Ni - Mp;
  B22 = A12*A12*Li + 2*A12*A22*Mi + A22*A22*Ni - Np;

  Standard_Real Discriminant = B12*B12 - B11*B22;

  if (Abs(Discriminant) < TolDiscr)
  {
    IsDiscriminantNull = Standard_True;
    if (Abs(B11) <= TolB && Abs(B22) <= TolB)
    {
#ifdef DRAW
      cout<<"Possible branching"<<endl<<endl;
#endif
      SignOfBcoeff = 0;
    }
    else
    {
      gp_Vec NewPreviousD3d;
      gp_Dir2d NewPreviousD2d;
      if (Abs(B11) > TolB)
      {
#ifdef DRAW
        cout<<"B11 = "<<B11<<endl;
#endif
        SignOfBcoeff = RealSign(B11);
      }
      else
      {
#ifdef DRAW
        cout<<"B22 = "<<B22<<endl;
#endif
        SignOfBcoeff = RealSign(B22);
      }
    }
  }
  else
  {
    IsDiscriminantNull = Standard_False;
#ifdef DRAW
    cout<<"Discriminant = "<<Discriminant<<endl;
#endif
  }
  return Standard_True;
}

void IntWalk_IWalking::AddPointInCurrentLine
         (const Standard_Integer N,
	  const ThePointOfPath& PathPnt,
	  const Handle(IntWalk_TheIWLine)& CurrentLine) const {


  IntSurf_PntOn2S Psol;
  Psol.SetValue(ThePointOfPathTool::Value3d(PathPnt),
		reversed,wd1[N].ustart,wd1[N].vstart);
  CurrentLine->AddPoint(Psol);
}


void IntWalk_IWalking::MakeWalkingPoint
         (const Standard_Integer Case, 
	  const Standard_Real U, 
	  const Standard_Real V,
	  TheIWFunction& sp,
	  IntSurf_PntOn2S& Psol )

{
// Case == 1      : make a WalkinkPoint.
// Case == 2      : make a WalkinkPoint.
//                  The computation of the tangency on is done  
// Case == 10 + i : make a WalkinkPoint according to i.
//                  but F is updated according to U and V
// Case == other  : the exception Standard_Failure is raised.

  if (Case == 1) 
    Psol.SetValue(sp.Point(),reversed, U, V);
  else if (Case == 2) {
    Psol.SetValue(sp.Point(),reversed, U, V);
  }
  else if (Case == 11 || Case == 12 ) {
    Standard_Real aUV[2], aFF[1], aDD[1][2];
    math_Vector UV(aUV,1, 2);
    math_Vector FF(aFF,1, 1);
    math_Matrix DD(aDD,1, 1, 1, 2); 
    UV(1) = U;
    UV(2) = V;
    sp.Values(UV, FF, DD);
    MakeWalkingPoint(Case - 10, U, V, sp, Psol);
  }
  else {
    Standard_ConstructionError::Raise();
  }
}

Standard_Boolean
 IntWalk_IWalking::ComputeDirOfTangentialIntersection(TheIWFunction& sp,
                                                      Standard_Integer& StepSignTangent,
                                                      Standard_Boolean& IsDiscriminantNull,
                                                      Standard_Integer& SignOfBcoeff,
                                                      gp_Vec&   newd3d,
                                                      gp_Dir2d& newd2d)
{
  gp_Vec Pu, Pv;
  Standard_Real B11, B22, B12;
  if (!ComputeB11orB22(sp, IsDiscriminantNull, SignOfBcoeff,
                       Pu, Pv, B11, B22, B12))
    return Standard_False;
  
  if (IsDiscriminantNull)
  {
    if (SignOfBcoeff != 0)
    {
      gp_Vec NewPreviousD3d;
      gp_Dir2d NewPreviousD2d;
      if (Abs(B11) > TolB)
      {
#ifdef DRAW
        cout<<"B11 = "<<B11<<endl;
#endif
        Standard_Real CoefPu = -B12/B11;
        NewPreviousD3d = CoefPu*Pu + Pv;
        NewPreviousD3d.Normalize();
        NewPreviousD2d = gp_Dir2d(CoefPu, 1.);
      }
      else
      {
#ifdef DRAW
        cout<<"B22 = "<<B22<<endl;
#endif
        Standard_Real CoefPv = -B12/B22;
        NewPreviousD3d = Pu + CoefPv*Pv;
        NewPreviousD3d.Normalize();
        NewPreviousD2d = gp_Dir2d(1., CoefPv);
      }
      
      if (!IsTangentialIntersection)
      {
        IsTangentialIntersection = Standard_True;
        if (NewPreviousD3d * previousd3d < 0)
          StepSignTangent = -1;
        else
          StepSignTangent = 1;
      }
      newd3d = StepSignTangent * NewPreviousD3d;
      newd2d = StepSignTangent * NewPreviousD2d;
    }
  }
  return Standard_True;
}

void IntWalk_IWalking::FindExactCuspPoint(TheIWFunction& sp,
                                          IntSurf_PntOn2S& Psol,
                                          const Standard_Integer SignFirst,
                                          const Standard_Integer SignLast)
{
  IntSurf_PntOn2S EndPoint = Psol;

  IntSurf_PntOn2S Pfirst, Plast;

  Standard_Real newU, newV;
  IntSurf_PntOn2S newPoint;

  Pfirst = previousPoint;
  Plast =  EndPoint;

  Standard_Integer newSign;

  for (;;)
  {
    Standard_Real Ufirst, Vfirst, Ulast, Vlast;
    Pfirst.ParametersOnSurface(reversed, Ufirst, Vfirst);
    Plast.ParametersOnSurface(reversed, Ulast, Vlast);
    
    newU = 0.5*(Ufirst + Ulast);
    newV = 0.5*(Vfirst + Vlast);

    if (Abs(newU - Ufirst) < tolerance(1) &&
        Abs(newV - Vfirst) < tolerance(2))
      break;
    
    MakeWalkingPoint(11, newU, newV, sp, newPoint);
    Standard_Boolean IsDiscriminantNull;
    gp_Vec Pu, Pv;
    Standard_Real B11, B22, B12;
    ComputeB11orB22(sp, IsDiscriminantNull, newSign,
                    Pu, Pv, B11, B22, B12);
    
    if (newSign == 0)
      break;

    if (newSign == SignFirst)
      Pfirst = newPoint;
    else //newSign == SignLast
      Plast = newPoint;
  }

  Psol = newPoint;
}


void IntWalk_IWalking::OpenLine(const Standard_Integer N,
                                const IntSurf_PntOn2S& Psol,
				const ThePOPIterator& Pnts1,
				TheIWFunction& sp,
                                const Handle(IntWalk_TheIWLine)& Line )
// **************** open the line and restart in the other direction********

{
  ThePointOfPath PathPnt;

  Standard_Real aUV[2], aFF[1], aDD[1][2];
  math_Vector UV(aUV,1, 2);
  math_Vector FF(aFF,1, 1);
  math_Matrix DD(aDD,1, 1, 1, 2); 

  previousPoint = Line->Value(1);  
  if (!reversed) {
    previousPoint.ParametersOnS2(UV(1),UV(2));
  }
  else {
    previousPoint.ParametersOnS1(UV(1),UV(2));
  }
  sp.Values(UV, FF, DD);
  if (sp.IsTangent())
  {
    IsTangentialIntersection = Standard_True;
    Standard_Integer theSign = 1;
    Standard_Integer theSignOfBcoeff = 0;
    gp_Vec   newd3d;
    gp_Dir2d newd2d;
    Standard_Boolean IsDiscriminantNull;
    ComputeDirOfTangentialIntersection(sp, theSign,
                                       IsDiscriminantNull, theSignOfBcoeff,
                                       newd3d, newd2d);
    previousd3d = newd3d;
    previousd2d = newd2d;
  }
  else
  {
    IsTangentialIntersection = Standard_False;
    previousd3d = sp.Direction3d();
    previousd2d = sp.Direction2d();
  }

  if (N>0) { //departure point given at input
    PathPnt = Pnts1.Value(N);
    //mark the line as open with a given stop point
    Line->AddStatusFirst(Standard_False,Standard_True,N,PathPnt); 


    AddPointInCurrentLine(N,PathPnt,Line);

  }
  else  {
    if (N <0) Line->AddPoint(Psol);                      
    Line->AddStatusFirst(Standard_False,Standard_False);
       //mark the line as open without given stop point 
  }
  Line->Reverse();  //inverser la ligne        
  Line->SetTangentVector(previousd3d.Reversed(),Line->NbPoints());
}








